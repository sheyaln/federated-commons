#!/bin/bash

# fetch-secrets - Fetch secrets from Scaleway Secret Manager

# Usage: fetch-secrets <app-name> <output-dir>
#
# Fetches secrets defined in the app's mapping file and writes them to the
# output directory. Designed to be called at container startup.
#
# Arguments:
#   app-name    - Name of the application (e.g., outline, authentik)
#   output-dir  - Directory to write secrets to (should be tmpfs)
#
# Example:
#   fetch-secrets outline /run/secrets


set -euo pipefail

# Configuration
SCW_CLI="{{ scw_cli_install_dir }}/scw"
SCW_CONFIG="{{ scw_secrets_config_dir }}/config.yaml"
MAPPINGS_DIR="{{ scw_secrets_mappings_dir }}"
LOG_LEVEL="{{ scw_secrets_log_level }}"
{% if scw_secrets_log_file | length > 0 %}
LOG_FILE="{{ scw_secrets_log_file }}"
{% else %}
LOG_FILE=""
{% endif %}

# -----------------------------------------------------------------------------
# Logging Functions
# -----------------------------------------------------------------------------
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Check if we should log this level
    case "$LOG_LEVEL" in
        debug) ;; # Log everything
        info)  [[ "$level" == "debug" ]] && return ;;
        warn)  [[ "$level" =~ ^(debug|info)$ ]] && return ;;
        error) [[ "$level" =~ ^(debug|info|warn)$ ]] && return ;;
    esac
    
    local log_line="[$timestamp] [$level] $message"
    
    # Always log errors to stderr
    if [[ "$level" == "error" ]]; then
        echo "$log_line" >&2
    fi
    
    # Log to file if configured
    if [[ -n "$LOG_FILE" ]]; then
        echo "$log_line" >> "$LOG_FILE"
    fi
    
    # Log to stdout for debug/info
    if [[ "$level" =~ ^(debug|info)$ ]]; then
        echo "$log_line"
    fi
}

log_debug() { log "debug" "$@"; }
log_info()  { log "info" "$@"; }
log_warn()  { log "warn" "$@"; }
log_error() { log "error" "$@"; }

# -----------------------------------------------------------------------------
# Validation
# -----------------------------------------------------------------------------
if [[ $# -lt 2 ]]; then
    log_error "Usage: fetch-secrets <app-name> <output-dir>"
    exit 1
fi

APP_NAME="$1"
OUTPUT_DIR="$2"

# Validate app name (alphanumeric, hyphens, underscores only)
if [[ ! "$APP_NAME" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    log_error "Invalid app name: $APP_NAME"
    exit 1
fi

# Check mapping file exists
MAPPING_FILE="${MAPPINGS_DIR}/${APP_NAME}.yml"
if [[ ! -f "$MAPPING_FILE" ]]; then
    log_error "Mapping file not found: $MAPPING_FILE"
    exit 1
fi

# Validate output directory
if [[ ! -d "$OUTPUT_DIR" ]]; then
    log_error "Output directory does not exist: $OUTPUT_DIR"
    exit 1
fi

# Check SCW CLI exists
if [[ ! -x "$SCW_CLI" ]]; then
    log_error "SCW CLI not found or not executable: $SCW_CLI"
    exit 1
fi

# Check SCW config exists
if [[ ! -f "$SCW_CONFIG" ]]; then
    log_error "SCW config not found: $SCW_CONFIG"
    exit 1
fi

# -----------------------------------------------------------------------------
# Parse Mapping File and Fetch Secrets
# -----------------------------------------------------------------------------
log_info "Fetching secrets for app: $APP_NAME"

# Parse YAML mapping file (simple format: secret_name: scw_secret_path)
# Format of mapping file:
#   secrets:
#     db_password: postgres-outline-credentials/password
#     secret_key: outline-secret-key
#     oidc_client_secret: outline-oidc-client-secret

FETCH_COUNT=0
FAIL_COUNT=0

# Extract secrets section from YAML (simple parsing without yq dependency)
while IFS=: read -r local_name scw_path; do
    # Skip empty lines and comments
    [[ -z "$local_name" || "$local_name" =~ ^[[:space:]]*# ]] && continue
    
    # Skip the 'secrets:' header line
    [[ "$local_name" =~ ^[[:space:]]*secrets ]] && continue
    
    # Clean up whitespace
    local_name=$(echo "$local_name" | xargs)
    scw_path=$(echo "$scw_path" | xargs)
    
    # Skip if either is empty
    [[ -z "$local_name" || -z "$scw_path" ]] && continue
    
    log_debug "Fetching secret: $local_name from $scw_path"
    
    # Parse the secret path (format: secret-name or secret-name/key)
    if [[ "$scw_path" == *"/"* ]]; then
        secret_name="${scw_path%/*}"
        secret_key="${scw_path#*/}"
    else
        secret_name="$scw_path"
        secret_key=""
    fi
    
    # Fetch the secret from Scaleway
    secret_value=$("$SCW_CLI" --config "$SCW_CONFIG" \
        secret version access-by-path \
        secret-name="$secret_name" \
        revision=latest \
        --output json 2>/dev/null) || {
        log_error "Failed to fetch secret: $scw_path"
        ((FAIL_COUNT++))
        continue
    }
    
    # Extract the data field (base64 encoded)
    raw_data=$(echo "$secret_value" | grep -o '"data":"[^"]*"' | cut -d'"' -f4)
    
    if [[ -z "$raw_data" ]]; then
        log_error "Empty data for secret: $scw_path"
        ((FAIL_COUNT++))
        continue
    fi
    
    # Decode from base64
    decoded_data=$(echo "$raw_data" | base64 -d 2>/dev/null) || {
        log_error "Failed to decode secret: $scw_path"
        ((FAIL_COUNT++))
        continue
    }
    
    # If a specific key was requested, parse JSON and extract it
    if [[ -n "$secret_key" ]]; then
        # Simple JSON extraction (assumes flat JSON object)
        extracted=$(echo "$decoded_data" | grep -o "\"$secret_key\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | cut -d'"' -f4)
        if [[ -z "$extracted" ]]; then
            log_error "Key '$secret_key' not found in secret: $secret_name"
            ((FAIL_COUNT++))
            continue
        fi
        decoded_data="$extracted"
    fi
    
    # Write to output file with secure permissions
    output_file="${OUTPUT_DIR}/${local_name}"
    echo -n "$decoded_data" > "$output_file"
    chmod 0400 "$output_file"
    
    log_debug "Wrote secret: $local_name"
    ((FETCH_COUNT++))
    
done < "$MAPPING_FILE"

# -----------------------------------------------------------------------------
# Summary
# -----------------------------------------------------------------------------
if [[ $FAIL_COUNT -gt 0 ]]; then
    log_error "Completed with errors: $FETCH_COUNT succeeded, $FAIL_COUNT failed"
    exit 1
fi

log_info "Successfully fetched $FETCH_COUNT secrets for $APP_NAME"
exit 0
